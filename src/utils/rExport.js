import JSZip from 'jszip'
import { useDataStore } from '../stores/data'

// Build info (injected by Vite)
const commitHash = typeof __COMMIT_HASH__ !== 'undefined' ? __COMMIT_HASH__ : 'dev'
const shortHash = commitHash.substring(0, 7)

// Generate citation text
const getCitationText = (recordCount) => {
  const date = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
  const url = window.location.href

  return `Ithomiini Distribution Maps. Data accessed on ${date}. ` +
    `${recordCount.toLocaleString()} records retrieved. ` +
    `Version: ${shortHash}. ` +
    `Available at: ${url}`
}

// Generate R script that recreates the map view
const generateRScript = (colorBy) => {
  const isItalic = colorBy === 'species' || colorBy === 'subspecies' || colorBy === 'genus' || colorBy === 'scientific_name'

  return `# ════════════════════════════════════════════════════════════════════════════════
# Ithomiini Distribution Map - R Script for Publication-Quality Export
# Generated by Ithomiini Maps (https://fr4nzz.github.io/ithomiini_maps/)
# ════════════════════════════════════════════════════════════════════════════════
#
# This script creates a map matching the web app preview with:
#   - Configurable basemap (via maptiles package)
#   - Styled legend with rounded corners
#   - Scale bar
#   - Point styling with stroke
#
# Output: PDF, PNG, and SVG files suitable for publications
# ════════════════════════════════════════════════════════════════════════════════

# ──────────────────────────────────────────────────────────────────────────────
# 1. INSTALL AND LOAD PACKAGES
# ──────────────────────────────────────────────────────────────────────────────

# All required packages
packages <- c(
  "sf",           # Spatial data handling
  "ggplot2",      # Plotting
  "dplyr",        # Data manipulation (pipes, joins)
  "tidyr",        # Data tidying (replace_na)
  "jsonlite",     # Read config files
  "maptiles",     # CartoDB basemap tiles
  "tidyterra",    # Plot raster tiles with ggplot2
  "ggspatial",    # Scale bar and north arrow
  "grid",         # Custom legend grobs
  "png"           # Read fallback basemap image
)

# Install missing packages
missing <- packages[!packages %in% installed.packages()[,"Package"]]
if (length(missing) > 0) {
  cat("Installing missing packages:", paste(missing, collapse = ", "), "\\n")
  install.packages(missing)
}

# Load all packages
invisible(lapply(packages, library, character.only = TRUE))

cat("All packages loaded\\n\\n")

# ──────────────────────────────────────────────────────────────────────────────
# 2. LOAD DATA
# ──────────────────────────────────────────────────────────────────────────────

cat("Loading exported data...\\n")

# Load spatial data and configs
points <- st_read("data.geojson", quiet = TRUE)
config <- fromJSON("view_config.json")
legend_data <- fromJSON("legend.json")

# Extract map bounds
bounds <- list(
  xmin = config$bounds$west,
  xmax = config$bounds$east,
  ymin = config$bounds$south,
  ymax = config$bounds$north
)

# Extract aspect ratio for dynamic output dimensions
aspect_ratio <- config$aspectRatio
if (is.null(aspect_ratio)) aspect_ratio <- 16/9  # fallback to 16:9

cat(sprintf("  %d points loaded\\n", nrow(points)))
cat(sprintf("  Bounds: [%.2f, %.2f] to [%.2f, %.2f]\\n",
            bounds$xmin, bounds$ymin, bounds$xmax, bounds$ymax))
cat(sprintf("  Aspect ratio: %.3f\\n", aspect_ratio))

# ──────────────────────────────────────────────────────────────────────────────
# 3. LOAD BASEMAP
# ──────────────────────────────────────────────────────────────────────────────

# Available basemap providers (change in STYLE section):
#   - "CartoDB.DarkMatter"   : Dark theme (default, matches web app) - supports retina
#   - "CartoDB.Positron"     : Light theme - supports retina
#   - "CartoDB.Voyager"      : Colored roads - supports retina
#   - "Stadia.AlidadeSmooth" : Smooth light theme - supports retina
#   - "Stadia.AlidadeSmoothDark" : Smooth dark theme - supports retina
#   - "OpenStreetMap"        : Standard OSM (no retina)
#   - "Esri.WorldImagery"    : Satellite imagery (no retina)
#   - "Esri.WorldTopoMap"    : Topographic (no retina)

# Note: STYLE is defined below, but we need basemap settings early
# CHANGE THESE to match your preferred basemap style and quality
basemap_provider <- "CartoDB.DarkMatter"
basemap_zoom <- NULL     # NULL = auto-detect, or set 1-18 (higher = more detail, slower)
basemap_retina <- TRUE   # TRUE = high-res tiles (2x) for CartoDB/Stadia providers

cat(sprintf("\\nLoading basemap (%s, retina=%s)...\\n", basemap_provider, basemap_retina))

# Create bounding box with small buffer for tile fetching
buffer <- 0.5
bbox_expanded <- st_bbox(c(
  xmin = bounds$xmin - buffer,
  ymin = bounds$ymin - buffer,
  xmax = bounds$xmax + buffer,
  ymax = bounds$ymax + buffer
), crs = 4326)

# Try to fetch tiles with high-resolution support
# retina=TRUE downloads 2x resolution tiles for supported providers (CartoDB, Stadia)
# zoom controls detail level (NULL = auto, higher = more detail but more tiles)
basemap <- NULL
tryCatch({
  basemap <- get_tiles(
    st_as_sfc(bbox_expanded),
    provider = basemap_provider,
    zoom = basemap_zoom,
    crop = TRUE,
    retina = basemap_retina
  )
  cat("  Basemap tiles loaded successfully\\n")
  if (basemap_retina) cat("  (High-resolution retina tiles)\\n")
}, error = function(e) {
  cat(sprintf("  Could not fetch tiles: %s\\n", e$message))
  cat("  Falling back to exported basemap.png\\n")
})

# Fallback to PNG if tiles failed
basemap_png <- NULL
if (is.null(basemap) && file.exists("basemap.png")) {
  basemap_png <- readPNG("basemap.png")
  cat("  Loaded basemap.png fallback\\n")
}

# ──────────────────────────────────────────────────────────────────────────────
# 4. PREPARE LEGEND DATA
# ──────────────────────────────────────────────────────────────────────────────

# Get max items from legend config (matches web app setting)
legend_max_items <- legend_data$maxItems
if (is.null(legend_max_items)) legend_max_items <- 15

# Create legend dataframe from exported items - PRESERVE ORDER from web app
# Do NOT re-sort - the items array is already in the correct display order
legend_df <- as.data.frame(legend_data$items)

# Add row index to preserve original order
legend_df$order_idx <- seq_len(nrow(legend_df))

cat(sprintf("\\nLegend: %d categories (showing max %d)\\n", nrow(legend_df), legend_max_items))

# ──────────────────────────────────────────────────────────────────────────────
# 5. STYLING CONFIGURATION (easy to customize!)
# ──────────────────────────────────────────────────────────────────────────────

STYLE <- list(
  # Background - use "#1a1a2e" for dark themes, "#f5f5f5" for light themes
  bg_color = "#1a1a2e",

  # Points
  point_size = 2.5,
  point_alpha = 0.85,
  point_stroke_color = "white",
  point_stroke_alpha = 0.3,
  point_stroke_width = 0.5,

  # Legend - for light themes use: bg="#ffffff", border="#cccccc",
  #          title_color="#666666", text_color="#333333"
  # Note: legend_max_items is read from legend.json to match web app
  legend_bg = "#252540",
  legend_bg_alpha = 0.95,    # Transparency (0 = transparent, 1 = opaque)
  legend_border = "#3d3d5c",
  legend_title_color = "#888888",
  legend_text_color = "#e0e0e0",
  legend_font_size = 8,
  legend_title_size = 10,
  legend_width = 0.22,
  legend_padding = 0.015,
  legend_item_height = 0.028,

  # Scale bar - use "#333333" for light themes
  scale_bar_color = "#e0e0e0",

  # Output dimensions and quality
  # Note: DPI affects text, points, and vector elements but NOT basemap tile resolution.
  # For sharper basemaps, set basemap_retina=TRUE above (2x tiles) and/or increase basemap_zoom.
  # PDF/SVG are vector formats - points/legend are infinitely scalable, only basemap is raster.
  # Dimensions are calculated from aspect_ratio to match web app export
  base_size = 12,  # base size in inches (width for landscape, height for portrait)
  dpi = 300        # dots per inch (affects PNG rasterization, not PDF/SVG vector parts)
)

# Calculate output dimensions from aspect ratio (matches web app export)
if (aspect_ratio >= 1) {
  # Landscape or square: width is base_size
  output_width <- STYLE$base_size
  output_height <- STYLE$base_size / aspect_ratio
} else {
  # Portrait: height is base_size
  output_height <- STYLE$base_size
  output_width <- STYLE$base_size * aspect_ratio
}
cat(sprintf("  Output size: %.1f x %.1f inches\\n", output_width, output_height))

# ──────────────────────────────────────────────────────────────────────────────
# 6. CREATE LEGEND GROB (with rounded corners)
# ──────────────────────────────────────────────────────────────────────────────

create_legend <- function(items, title, max_items, italic = FALSE, style = STYLE) {
  n_items <- min(nrow(items), max_items)
  has_more <- nrow(items) > max_items

  # Calculate dimensions
  title_h <- style$legend_item_height * 1.8
  content_h <- n_items * style$legend_item_height
  more_h <- if (has_more) style$legend_item_height * 1.2 else 0
  total_h <- title_h + content_h + more_h + style$legend_padding * 3

  # Find max label width using ONLY VISIBLE items (first n_items)
  visible_items <- items$label[1:n_items]
  max_label_len <- max(nchar(visible_items))
  legend_w <- max(style$legend_width, 0.01 * max_label_len + 0.06)

  # Position (bottom-left with padding)
  x0 <- 0.02
  y0 <- 0.08

  grobs <- list()

  # Background with rounded corners
  grobs$bg <- roundrectGrob(
    x = x0, y = y0,
    width = legend_w, height = total_h,
    just = c("left", "bottom"),
    r = unit(8, "pt"),
    gp = gpar(
      fill = alpha(style$legend_bg, style$legend_bg_alpha),
      col = style$legend_border,
      lwd = 1
    )
  )

  # Title
  grobs$title <- textGrob(
    toupper(title),
    x = x0 + style$legend_padding,
    y = y0 + total_h - style$legend_padding - title_h/2,
    just = c("left", "center"),
    gp = gpar(
      col = style$legend_title_color,
      fontsize = style$legend_title_size,
      fontface = "bold"
    )
  )

  # Legend items
  for (i in seq_len(n_items)) {
    item_y <- y0 + total_h - title_h - style$legend_padding - (i - 0.5) * style$legend_item_height

    # Color dot with white stroke
    grobs[[paste0("dot_", i)]] <- circleGrob(
      x = x0 + style$legend_padding + 0.012,
      y = item_y,
      r = 0.006,
      gp = gpar(
        fill = items$color[i],
        col = alpha("white", 0.3),
        lwd = 0.5
      )
    )

    # Label
    grobs[[paste0("label_", i)]] <- textGrob(
      items$label[i],
      x = x0 + style$legend_padding + 0.028,
      y = item_y,
      just = c("left", "center"),
      gp = gpar(
        col = style$legend_text_color,
        fontsize = style$legend_font_size,
        fontface = if (italic) "italic" else "plain"
      )
    )
  }

  # "More" indicator if truncated
  if (has_more) {
    grobs$more <- textGrob(
      sprintf("+ %d more...", nrow(items) - max_items),
      x = x0 + style$legend_padding,
      y = y0 + style$legend_padding + more_h/2,
      just = c("left", "center"),
      gp = gpar(
        col = style$legend_title_color,
        fontsize = style$legend_font_size - 1,
        fontface = "italic"
      )
    )
  }

  do.call(grobTree, grobs)
}

# ──────────────────────────────────────────────────────────────────────────────
# 7. BUILD THE MAP
# ──────────────────────────────────────────────────────────────────────────────

cat("\\nCreating map...\\n")

# Start building the plot
p <- ggplot()

# Add basemap layer
if (!is.null(basemap)) {
  p <- p + geom_spatraster_rgb(data = basemap)
} else if (!is.null(basemap_png)) {
  p <- p + annotation_raster(
    basemap_png,
    xmin = bounds$xmin, xmax = bounds$xmax,
    ymin = bounds$ymin, ymax = bounds$ymax
  )
}

# Add data points with stroke (matching web app style)
p <- p +
  geom_sf(
    data = points,
    aes(fill = display_color),
    color = alpha(STYLE$point_stroke_color, STYLE$point_stroke_alpha),
    size = STYLE$point_size,
    alpha = STYLE$point_alpha,
    stroke = STYLE$point_stroke_width,
    shape = 21
  ) +
  scale_fill_identity()

# Set coordinate system and bounds
p <- p +
  coord_sf(
    xlim = c(bounds$xmin, bounds$xmax),
    ylim = c(bounds$ymin, bounds$ymax),
    expand = FALSE
  )

# Add scale bar using ggspatial
p <- p +
  annotation_scale(
    location = "br",
    width_hint = 0.15,
    style = "ticks",
    text_col = STYLE$scale_bar_color,
    line_col = STYLE$scale_bar_color,
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm")
  )

# Apply theme
p <- p +
  theme_void() +
  theme(
    plot.background = element_rect(fill = STYLE$bg_color, color = NA),
    panel.background = element_rect(fill = STYLE$bg_color, color = NA)
  )

# Add custom legend
p_final <- p +
  annotation_custom(
    create_legend(legend_df, legend_data$title, legend_max_items, ${isItalic ? 'TRUE' : 'FALSE'}),
    xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
  )

# ──────────────────────────────────────────────────────────────────────────────
# 8. SAVE OUTPUTS
# ──────────────────────────────────────────────────────────────────────────────

cat("\\nSaving outputs...\\n")

# Preview in RStudio
print(p_final)

# Save as PDF (vector graphics for publications)
ggsave("ithomiini_map.pdf", plot = p_final,
       width = output_width, height = output_height, dpi = STYLE$dpi)
cat("  ithomiini_map.pdf\\n")

# Save as high-resolution PNG
ggsave("ithomiini_map.png", plot = p_final,
       width = output_width, height = output_height, dpi = STYLE$dpi)
cat("  ithomiini_map.png\\n")

# Save as SVG (editable vector)
ggsave("ithomiini_map.svg", plot = p_final,
       width = output_width, height = output_height, dpi = STYLE$dpi)
cat("  ithomiini_map.svg\\n")

cat("\\n════════════════════════════════════════════════════════════════════════════════\\n")
cat("Export complete!\\n")
cat("\\nOutput files:\\n")
cat("  ithomiini_map.pdf - Vector PDF for publications\\n")
cat("  ithomiini_map.png - High-resolution raster (300 DPI)\\n")
cat("  ithomiini_map.svg - Editable vector (Adobe Illustrator/Inkscape)\\n")
cat("\\nTip: Edit the STYLE list above to customize colors, sizes, and layout.\\n")
cat("════════════════════════════════════════════════════════════════════════════════\\n")
`
}

// Generate README for the ZIP
const generateReadme = (citationText) => {
  return `═══════════════════════════════════════════════════════════════════════════
ITHOMIINI MAPS - R EXPORT PACKAGE
═══════════════════════════════════════════════════════════════════════════

This ZIP contains data and scripts to recreate your map view as true
vector graphics (SVG/PDF) for publications.

FILES INCLUDED:
---------------
- data.geojson      : Filtered specimen data with pre-computed colors
- view_config.json  : Map view bounds and settings
- legend.json       : Legend colors and labels
- basemap.png       : Exact basemap from web app (CartoDB Dark tiles)
- map.html          : Standalone HTML file (EXACT reproduction of web preview)
- generate_map.R    : R script to recreate the map
- README.txt        : This file

QUICK START:
------------
1. Extract all files to a folder
2. Open R or RStudio
3. Set working directory to the extracted folder
4. Run: source("generate_map.R")
5. Find your exports in the folder

OUTPUT FILES:
-------------
- ithomiini_map.pdf : Vector PDF for publications
- ithomiini_map.png : High-resolution raster (300 DPI)
- ithomiini_map.svg : Editable vector (Adobe Illustrator/Inkscape)

REQUIREMENTS:
-------------
All packages will auto-install if missing:
- sf               : Spatial data handling
- ggplot2          : Plotting
- dplyr            : Data manipulation
- tidyr            : Data tidying
- jsonlite         : Reading config files
- maptiles         : CartoDB Dark Matter basemap tiles
- tidyterra        : Plot raster tiles with ggplot2
- ggspatial        : Scale bar
- grid             : Custom legend rendering
- png              : Read fallback basemap image

VIEWING IN BROWSER (map.html):
------------------------------
The map.html file is a standalone HTML file that renders identically to the
web app preview. You can open it directly in any browser to view and interact
with the map.

WHY R?
------
The web map uses WebGL rendering which produces raster (pixel) output.
R with ggplot2 renders true vectors, giving you:
- Infinite scalability for any print size
- Small file sizes
- Editable in Adobe Illustrator/Inkscape
- Publication-quality output

CUSTOMIZATION:
--------------
Edit the STYLE list in generate_map.R to easily customize:
- Point size, color, and transparency
- Legend position, size, and max items shown
- Background and text colors
- Scale bar styling
- Output dimensions and DPI

The script is well-documented and uses tidyverse conventions for
easy modification.

CITATION:
---------
${citationText}

SOURCE:
-------
https://fr4nzz.github.io/ithomiini_maps/

Generated: ${new Date().toISOString()}
Version: ${shortHash}
═══════════════════════════════════════════════════════════════════════════
`
}

// Generate standalone HTML file that renders exact same map as web app
const generateMapHTML = (geoJSON, viewConfig, legendConfig, colorBy) => {
  const isItalic = colorBy === 'species' || colorBy === 'subspecies' || colorBy === 'genus' || colorBy === 'scientific_name'
  const legendItems = legendConfig.items || []

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Ithomiini Distribution Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"><\/script>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    #map { width: 100vw; height: 100vh; }

    /* Legend - matches web app exactly */
    .legend {
      position: absolute;
      bottom: 40px;
      left: 20px;
      background: rgba(37, 37, 64, 0.95);
      border: 1px solid #3d3d5c;
      border-radius: 8px;
      padding: 12px;
      max-height: 60vh;
      overflow-y: auto;
      min-width: 180px;
      z-index: 1000;
    }
    .legend-title {
      color: #888888;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 3px 0;
    }
    .legend-color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .legend-label {
      color: #e0e0e0;
      font-size: 12px;
      ${isItalic ? 'font-style: italic;' : ''}
    }

    /* Scale bar */
    .maplibregl-ctrl-scale {
      background: rgba(37, 37, 64, 0.9) !important;
      color: #e0e0e0 !important;
      border-color: #e0e0e0 !important;
      font-size: 11px !important;
    }

    /* Hide attribution for cleaner export */
    .maplibregl-ctrl-attrib { display: none !important; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="legend">
    <div class="legend-title">${legendConfig.title || colorBy}</div>
    ${legendItems.map(item => `
    <div class="legend-item">
      <div class="legend-color" style="background: ${item.color}"></div>
      <span class="legend-label">${item.label}</span>
    </div>
    `).join('')}
  </div>

  <script>
    // GeoJSON data embedded
    const geoData = ${JSON.stringify(geoJSON)};

    // View config
    const config = ${JSON.stringify(viewConfig)};

    // Initialize map
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          'carto-dark': {
            type: 'raster',
            tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'],
            tileSize: 256,
            attribution: '© CartoDB © OpenStreetMap'
          }
        },
        layers: [{
          id: 'carto-dark-layer',
          type: 'raster',
          source: 'carto-dark',
          minzoom: 0,
          maxzoom: 22
        }]
      },
      center: [config.center.lng, config.center.lat],
      zoom: config.zoom,
      preserveDrawingBuffer: true // Required for canvas export
    });

    // Add scale bar
    map.addControl(new maplibregl.ScaleControl({ unit: 'metric' }), 'bottom-right');

    map.on('load', () => {
      // Add data source
      map.addSource('points', {
        type: 'geojson',
        data: geoData
      });

      // Add points layer with exact colors from web app
      map.addLayer({
        id: 'points-layer',
        type: 'circle',
        source: 'points',
        paint: {
          'circle-radius': 6,
          'circle-color': ['get', 'display_color'],
          'circle-opacity': 0.8,
          'circle-stroke-width': 1,
          'circle-stroke-color': 'rgba(255,255,255,0.3)'
        }
      });

      // Fit to bounds
      map.fitBounds([
        [config.bounds.west, config.bounds.south],
        [config.bounds.east, config.bounds.north]
      ], { padding: 20, duration: 0 });
    });
  <\/script>
</body>
</html>`
}

/**
 * Export data for R - generates a ZIP file with all necessary files
 * @param {Object} map - The MapLibre map instance
 * @returns {Promise<void>}
 */
export async function exportForR(map) {
  if (!map) {
    throw new Error('Map not available. Please ensure you are on the Map view.')
  }

  const store = useDataStore()
  const geo = store.filteredGeoJSON

  if (!geo || !geo.features || geo.features.length === 0) {
    throw new Error('No data to export')
  }

  // Get map bounds directly (map container is sized to aspect ratio)
  const mapBounds = map.getBounds()
  const center = map.getCenter()
  const zoom = map.getZoom()

  // Prepare GeoJSON with color information
  const colorMap = store.activeColorMap
  const colorBy = store.colorBy

  // Add color to each feature
  const featuresWithColors = geo.features.map(f => {
    const key = f.properties[colorBy] || 'Unknown'
    return {
      ...f,
      properties: {
        ...f.properties,
        display_color: colorMap[key] || '#888888'
      }
    }
  })

  const exportGeoJSON = {
    type: 'FeatureCollection',
    metadata: {
      title: 'Ithomiini Distribution Data',
      version: shortHash,
      exportDate: new Date().toISOString(),
      recordCount: geo.features.length,
      colorBy: colorBy,
      source: 'https://fr4nzz.github.io/ithomiini_maps/'
    },
    features: featuresWithColors
  }

  // Calculate aspect ratio from map container
  const container = map.getContainer()
  const aspectRatio = container.clientWidth / container.clientHeight

  // View configuration (using map bounds directly)
  const viewConfig = {
    bounds: {
      west: mapBounds.getWest(),
      south: mapBounds.getSouth(),
      east: mapBounds.getEast(),
      north: mapBounds.getNorth()
    },
    center: {
      lng: center.lng,
      lat: center.lat
    },
    zoom: zoom,
    colorBy: colorBy,
    aspectRatio: aspectRatio  // Used by R to set correct output dimensions
  }

  // Legend configuration - preserve order from colorMap (which matches web app display order)
  // Get legend items in the same order as they appear in the web app
  const legendItems = Object.entries(colorMap).map(([label, color]) => ({
    label,
    color
  }))

  const legendConfig = {
    title: store.legendTitle,
    colorBy: colorBy,
    maxItems: store.legendSettings.maxItems,  // Pass max items setting to R
    colors: colorMap,
    items: legendItems
  }

  // Generate R script
  const rScript = generateRScript(colorBy)

  // Capture basemap as raster (without data points)
  let basemapDataUrl = null
  const dataLayers = ['points-layer', 'points-glow', 'clusters', 'cluster-count']
  const layerVisibility = {}

  try {
    // Temporarily hide data layers to capture just the basemap
    dataLayers.forEach(layerId => {
      if (map.getLayer(layerId)) {
        layerVisibility[layerId] = map.getLayoutProperty(layerId, 'visibility')
        map.setLayoutProperty(layerId, 'visibility', 'none')
      }
    })

    // Wait for render
    map.triggerRepaint()
    await new Promise(resolve => map.once('idle', resolve))

    // Capture basemap canvas directly (no cropping needed)
    basemapDataUrl = map.getCanvas().toDataURL('image/png')
  } catch (e) {
    console.warn('[Export] Could not capture basemap:', e)
  } finally {
    // ALWAYS restore layer visibility, even if capture failed
    dataLayers.forEach(layerId => {
      if (map.getLayer(layerId)) {
        const originalVisibility = layerVisibility[layerId]
        if (originalVisibility !== undefined) {
          map.setLayoutProperty(layerId, 'visibility', originalVisibility || 'visible')
        } else {
          // If we didn't capture original state, default to visible
          map.setLayoutProperty(layerId, 'visibility', 'visible')
        }
      }
    })

    // Wait for render to restore
    map.triggerRepaint()
    await new Promise(resolve => map.once('idle', resolve))
  }

  // Generate citation text
  const citationText = getCitationText(geo.features.length)

  // Generate HTML file for exact reproduction
  const mapHTML = generateMapHTML(exportGeoJSON, viewConfig, legendConfig, colorBy)

  // Create ZIP file
  const zip = new JSZip()
  zip.file('data.geojson', JSON.stringify(exportGeoJSON, null, 2))
  zip.file('view_config.json', JSON.stringify(viewConfig, null, 2))
  zip.file('legend.json', JSON.stringify(legendConfig, null, 2))
  zip.file('generate_map.R', rScript)
  zip.file('map.html', mapHTML)
  zip.file('README.txt', generateReadme(citationText))

  // Add basemap if captured
  if (basemapDataUrl) {
    const basemapBase64 = basemapDataUrl.split(',')[1]
    zip.file('basemap.png', basemapBase64, { base64: true })
  }

  // Generate and download ZIP
  const content = await zip.generateAsync({ type: 'blob' })
  const url = URL.createObjectURL(content)
  const link = document.createElement('a')
  link.href = url
  link.download = `ithomiini_r_export_${shortHash}_${Date.now()}.zip`
  link.click()
  URL.revokeObjectURL(url)
}
