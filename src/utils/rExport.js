import JSZip from 'jszip'
import { useDataStore } from '../stores/data'
import { useLegendStore } from '../stores/legend'
import { generateAbbreviationOptions, applyAbbreviationFormat } from './abbreviations'
import { SHAPE_OPTIONS } from './shapes'

// Build info (injected by Vite)
const commitHash = typeof __COMMIT_HASH__ !== 'undefined' ? __COMMIT_HASH__ : 'dev'
const shortHash = commitHash.substring(0, 7)

// Generate citation text
const getCitationText = (recordCount) => {
  const date = new Date().toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  })
  const url = window.location.href

  return `Ithomiini Distribution Maps. Data accessed on ${date}. ` +
    `${recordCount.toLocaleString()} records retrieved. ` +
    `Version: ${shortHash}. ` +
    `Available at: ${url}`
}

// Generate R script that recreates the map view
const generateRScript = (colorBy, legendSettings) => {
  const isItalic = colorBy === 'species' || colorBy === 'subspecies' || colorBy === 'genus' || colorBy === 'scientific_name'

  // Extract legend position for R (normalize to 0-1 scale)
  const legendPosX = legendSettings.position?.x ?? 40
  const legendPosY = legendSettings.position?.y ?? null
  // Convert pixel position to normalized (0-1) coordinates
  // Default bottom-left positioning
  const rLegendX = 0.02  // Will be overridden by legendSettings if available
  const rLegendY = 0.08  // Will be overridden by legendSettings if available

  return `# ════════════════════════════════════════════════════════════════════════════════
# Ithomiini Distribution Map - R Script for Publication-Quality Export
# Generated by Ithomiini Maps (https://fr4nzz.github.io/ithomiini_maps/)
# ════════════════════════════════════════════════════════════════════════════════
#
# This script creates a map matching the web app preview with:
#   - Configurable basemap (via maptiles package)
#   - Styled legend with rounded corners and optional shapes
#   - Scale bar
#   - Point styling with stroke and optional shapes per group
#   - Display name formatting (predefined or custom)
#
# Output: PDF, PNG, and SVG files suitable for publications
# ════════════════════════════════════════════════════════════════════════════════

# ──────────────────────────────────────────────────────────────────────────────
# 1. INSTALL AND LOAD PACKAGES
# ──────────────────────────────────────────────────────────────────────────────

# All required packages
packages <- c(
  "sf",           # Spatial data handling
  "ggplot2",      # Plotting
  "dplyr",        # Data manipulation (pipes, joins)
  "tidyr",        # Data tidying (replace_na)
  "jsonlite",     # Read config files
  "maptiles",     # CartoDB basemap tiles
  "tidyterra",    # Plot raster tiles with ggplot2
  "ggspatial",    # Scale bar and north arrow
  "grid",         # Custom legend grobs
  "png",          # Read fallback basemap image
  "stringr"       # String manipulation for abbreviations
)

# Install missing packages
missing <- packages[!packages %in% installed.packages()[,"Package"]]
if (length(missing) > 0) {
  cat("Installing missing packages:", paste(missing, collapse = ", "), "\\n")
  install.packages(missing)
}

# Load all packages
invisible(lapply(packages, library, character.only = TRUE))

cat("All packages loaded\\n\\n")

# ──────────────────────────────────────────────────────────────────────────────
# 2. LOAD DATA
# ──────────────────────────────────────────────────────────────────────────────

cat("Loading exported data...\\n")

# Load spatial data and configs
points <- st_read("data.geojson", quiet = TRUE)
config <- fromJSON("view_config.json")
legend_data <- fromJSON("legend.json")

# Extract map bounds
bounds <- list(
  xmin = config$bounds$west,
  xmax = config$bounds$east,
  ymin = config$bounds$south,
  ymax = config$bounds$north
)

# Extract aspect ratio for dynamic output dimensions
aspect_ratio <- config$aspectRatio
if (is.null(aspect_ratio)) aspect_ratio <- 16/9  # fallback to 16:9

cat(sprintf("  %d points loaded\\n", nrow(points)))
cat(sprintf("  Bounds: [%.2f, %.2f] to [%.2f, %.2f]\\n",
            bounds$xmin, bounds$ymin, bounds$xmax, bounds$ymax))
cat(sprintf("  Aspect ratio: %.3f\\n", aspect_ratio))

# ──────────────────────────────────────────────────────────────────────────────
# 3. LOAD BASEMAP
# ──────────────────────────────────────────────────────────────────────────────

# Available basemap providers (change in STYLE section):
#   - "CartoDB.DarkMatter"   : Dark theme (default, matches web app) - supports retina
#   - "CartoDB.Positron"     : Light theme - supports retina
#   - "CartoDB.Voyager"      : Colored roads - supports retina
#   - "Stadia.AlidadeSmooth" : Smooth light theme - supports retina
#   - "Stadia.AlidadeSmoothDark" : Smooth dark theme - supports retina
#   - "OpenStreetMap"        : Standard OSM (no retina)
#   - "Esri.WorldImagery"    : Satellite imagery (no retina)
#   - "Esri.WorldTopoMap"    : Topographic (no retina)

# Note: STYLE is defined below, but we need basemap settings early
# CHANGE THESE to match your preferred basemap style and quality
basemap_provider <- "CartoDB.DarkMatter"
basemap_zoom <- NULL     # NULL = auto-detect, or set 1-18 (higher = more detail, slower)
basemap_retina <- TRUE   # TRUE = high-res tiles (2x) for CartoDB/Stadia providers

cat(sprintf("\\nLoading basemap (%s, retina=%s)...\\n", basemap_provider, basemap_retina))

# Create bounding box with small buffer for tile fetching
buffer <- 0.5
bbox_expanded <- st_bbox(c(
  xmin = bounds$xmin - buffer,
  ymin = bounds$ymin - buffer,
  xmax = bounds$xmax + buffer,
  ymax = bounds$ymax + buffer
), crs = 4326)

# Try to fetch tiles with high-resolution support
# retina=TRUE downloads 2x resolution tiles for supported providers (CartoDB, Stadia)
# zoom controls detail level (NULL = auto, higher = more detail but more tiles)
basemap <- NULL
tryCatch({
  basemap <- get_tiles(
    st_as_sfc(bbox_expanded),
    provider = basemap_provider,
    zoom = basemap_zoom,
    crop = TRUE,
    retina = basemap_retina
  )
  cat("  Basemap tiles loaded successfully\\n")
  if (basemap_retina) cat("  (High-resolution retina tiles)\\n")
}, error = function(e) {
  cat(sprintf("  Could not fetch tiles: %s\\n", e$message))
  cat("  Falling back to exported basemap.png\\n")
})

# Fallback to PNG if tiles failed
basemap_png <- NULL
if (is.null(basemap) && file.exists("basemap.png")) {
  basemap_png <- readPNG("basemap.png")
  cat("  Loaded basemap.png fallback\\n")
}

# ──────────────────────────────────────────────────────────────────────────────
# 4. PREPARE LEGEND DATA
# ──────────────────────────────────────────────────────────────────────────────

# Get max items from legend config (matches web app setting)
legend_max_items <- legend_data$maxItems
if (is.null(legend_max_items)) legend_max_items <- 15

# Create legend dataframe from exported items - PRESERVE ORDER from web app
# Do NOT re-sort - the items array is already in the correct display order
legend_df <- as.data.frame(legend_data$items)

# Add row index to preserve original order
legend_df$order_idx <- seq_len(nrow(legend_df))

cat(sprintf("\\nLegend: %d categories (showing max %d)\\n", nrow(legend_df), legend_max_items))

# ──────────────────────────────────────────────────────────────────────────────
# 5. DISPLAY NAME FORMATTING FUNCTIONS
# ──────────────────────────────────────────────────────────────────────────────
# These functions generate abbreviated names for scientific names.
# You can change display_name_format and prefix_format in the SETTINGS section below.
#
# Available display_name_format options:
#   "full"             - Full species name: "Mechanitis polymnia"
#   "firstLetterGenus" - First letter + epithet: "M. polymnia"
#   "syllableGenus"    - First syllable + epithet: "Mec. polymnia"
#   "custom"           - Use custom names from legend_data$displayNames
#
# Available prefix_format options:
#   "none"             - No prefix: "casabranca"
#   "firstLetterBoth"  - First letters: "M. p. casabranca"
#   "syllableBoth"     - First syllables: "Mec. pol. casabranca"
#   "custom"           - Use custom prefixes from legend_data$abbreviations

# Get first syllable of a word (smart syllable detection)
# Finds first vowel cluster, includes consonants after, minimum 2-3 chars
get_first_syllable <- function(word) {
  if (is.null(word) || nchar(word) <= 3) return(word)

  vowels <- c("a", "e", "i", "o", "u", "y")
  lower <- tolower(word)
  chars <- strsplit(lower, "")[[1]]

  result <- ""
  found_vowel <- FALSE
  vowel_ended <- FALSE


  for (i in seq_along(chars)) {
    char <- chars[i]
    is_vowel <- char %in% vowels

    if (!found_vowel) {
      result <- paste0(result, char)
      if (is_vowel) found_vowel <- TRUE
    } else if (!vowel_ended) {
      if (is_vowel) {
        result <- paste0(result, char)
      } else {
        vowel_ended <- TRUE
        result <- paste0(result, char)
        if (nchar(result) >= 3) break
      }
    } else {
      if (is_vowel) break
      result <- paste0(result, char)
      if (nchar(result) >= 4) break
    }
  }

  if (nchar(result) < 2) {
    result <- substr(lower, 1, min(3, nchar(lower)))
  }

  # Capitalize first letter and add period
  paste0(toupper(substr(result, 1, 1)), substr(result, 2, nchar(result)), ".")
}

# Generate abbreviation options for a species name
generate_abbreviations <- function(species_name) {
  if (is.null(species_name) || species_name == "") return(list(full = species_name))

  parts <- strsplit(trimws(species_name), "\\\\s+")[[1]]
  if (length(parts) < 2) {
    return(list(full = species_name, firstLetterGenus = species_name, syllableGenus = species_name))
  }

  genus <- parts[1]
  epithet <- paste(parts[-1], collapse = " ")
  first_epithet <- parts[2]

  # First letter abbreviations
  genus_first <- paste0(toupper(substr(genus, 1, 1)), ".")
  epithet_first <- paste0(tolower(substr(first_epithet, 1, 1)), ".")

  # Syllable abbreviations
  genus_syll <- get_first_syllable(genus)
  epithet_syll <- tolower(get_first_syllable(first_epithet))

  list(
    full = species_name,
    firstLetterGenus = paste(genus_first, epithet),
    firstLetterBoth = paste(genus_first, epithet_first),
    syllableGenus = paste(genus_syll, epithet),
    syllableBoth = paste(genus_syll, epithet_syll)
  )
}

# Apply display name format to a species name
apply_display_format <- function(species_name, format, custom_names = NULL) {
  if (format == "custom" && !is.null(custom_names) && species_name %in% names(custom_names)) {
    return(custom_names[[species_name]])
  }

  abbrevs <- generate_abbreviations(species_name)

  switch(format,
    "full" = abbrevs$full,
    "firstLetterGenus" = abbrevs$firstLetterGenus,
    "syllableGenus" = abbrevs$syllableGenus,
    abbrevs$full  # default
  )
}

# Apply prefix format to get abbreviation prefix
apply_prefix_format <- function(species_name, format, custom_abbrevs = NULL) {
  if (format == "none") return("")

  if (format == "custom" && !is.null(custom_abbrevs) && species_name %in% names(custom_abbrevs)) {
    return(custom_abbrevs[[species_name]])
  }

  abbrevs <- generate_abbreviations(species_name)

  switch(format,
    "firstLetterBoth" = abbrevs$firstLetterBoth,
    "syllableBoth" = abbrevs$syllableBoth,
    "none" = "",
    abbrevs$syllableBoth  # default
  )
}

# ──────────────────────────────────────────────────────────────────────────────
# 6. SHAPE UTILITIES FOR GGPLOT2
# ──────────────────────────────────────────────────────────────────────────────
# ggplot2 shape codes for common shapes:
#   21 = circle (filled, with border)      ●
#   22 = square (filled, with border)      ■
#   24 = triangle up (filled, with border) ▲
#   23 = diamond (filled, with border)     ◆
#
# To change a group's shape, modify the shape_map list below or
# change the shape column in the data.
#
# Shape reference (all filled shapes that support fill + color):
#   21 = circle, 22 = square, 23 = diamond, 24 = triangle up, 25 = triangle down

SHAPE_CODES <- list(
  circle = 21,    # Filled circle with border
  square = 22,    # Filled square with border
  triangle = 24,  # Filled triangle (up) with border
  rhombus = 23    # Filled diamond with border
)

# Convert shape name to ggplot2 shape code
get_shape_code <- function(shape_name) {
  code <- SHAPE_CODES[[shape_name]]
  if (is.null(code)) return(21)  # default to circle
  code
}

# ──────────────────────────────────────────────────────────────────────────────
# 7. LEGEND SETTINGS (from web app export)
# ──────────────────────────────────────────────────────────────────────────────

# Load legend settings from JSON
show_headers <- if (!is.null(legend_data$showHeaders)) legend_data$showHeaders else FALSE
display_name_format <- if (!is.null(legend_data$displayNameFormat)) legend_data$displayNameFormat else "full"
prefix_format <- if (!is.null(legend_data$prefixFormat)) legend_data$prefixFormat else "syllableBoth"
shapes_enabled <- if (!is.null(legend_data$shapesEnabled)) legend_data$shapesEnabled else FALSE

# Custom names/abbreviations (if format is "custom")
custom_display_names <- legend_data$displayNames
custom_abbreviations <- legend_data$abbreviations

# Per-group shape assignments
group_shapes <- legend_data$groupShapes
if (is.null(group_shapes)) group_shapes <- list()

# Legend position (normalized 0-1 coordinates)
legend_pos_x <- if (!is.null(legend_data$position$x)) legend_data$position$x else 0.02
legend_pos_y <- if (!is.null(legend_data$position$y)) legend_data$position$y else 0.08

cat(sprintf("  Display name format: %s\\n", display_name_format))
cat(sprintf("  Prefix format: %s\\n", prefix_format))
cat(sprintf("  Show headers: %s\\n", show_headers))
cat(sprintf("  Shapes enabled: %s\\n", shapes_enabled))

# ──────────────────────────────────────────────────────────────────────────────
# 8. STYLING CONFIGURATION (easy to customize!)
# ──────────────────────────────────────────────────────────────────────────────

STYLE <- list(
  # Background - use "#1a1a2e" for dark themes, "#f5f5f5" for light themes
  bg_color = "#1a1a2e",

  # Points
  point_size = 2.5,
  point_alpha = 0.85,
  point_stroke_color = "white",
  point_stroke_alpha = 0.3,
  point_stroke_width = 0.5,

  # Legend - for light themes use: bg="#ffffff", border="#cccccc",
  #          title_color="#666666", text_color="#333333"
  # Note: legend_max_items is read from legend.json to match web app
  legend_bg = "#252540",
  legend_bg_alpha = 0.95,    # Transparency (0 = transparent, 1 = opaque)
  legend_border = "#3d3d5c",
  legend_title_color = "#888888",
  legend_text_color = "#e0e0e0",
  legend_font_size = 8,
  legend_title_size = 10,
  legend_width = 0.22,
  legend_padding = 0.015,
  legend_item_height = 0.028,

  # Scale bar - use "#333333" for light themes
  scale_bar_color = "#e0e0e0",

  # Output dimensions and quality
  # Note: DPI affects text, points, and vector elements but NOT basemap tile resolution.
  # For sharper basemaps, set basemap_retina=TRUE above (2x tiles) and/or increase basemap_zoom.
  # PDF/SVG are vector formats - points/legend are infinitely scalable, only basemap is raster.
  # Dimensions are calculated from aspect_ratio to match web app export
  base_size = 12,  # base size in inches (width for landscape, height for portrait)
  dpi = 300        # dots per inch (affects PNG rasterization, not PDF/SVG vector parts)
)

# Calculate output dimensions from aspect ratio (matches web app export)
if (aspect_ratio >= 1) {
  # Landscape or square: width is base_size
  output_width <- STYLE$base_size
  output_height <- STYLE$base_size / aspect_ratio
} else {
  # Portrait: height is base_size
  output_height <- STYLE$base_size
  output_width <- STYLE$base_size * aspect_ratio
}
cat(sprintf("  Output size: %.1f x %.1f inches\\n", output_width, output_height))

# ──────────────────────────────────────────────────────────────────────────────
# 9. CREATE LEGEND GROB (with rounded corners, shapes, and grouping)
# ──────────────────────────────────────────────────────────────────────────────

# Helper function to draw a shape in a grob
create_shape_grob <- function(x, y, shape, fill_color, stroke_color = "white", stroke_alpha = 0.3, size = 0.006) {
  shape_code <- get_shape_code(shape)

  # Use pointsGrob for consistent shape rendering
  pointsGrob(
    x = x, y = y,
    pch = shape_code,
    size = unit(size * 2, "npc"),
    gp = gpar(
      fill = fill_color,
      col = alpha(stroke_color, stroke_alpha),
      lwd = 0.5
    )
  )
}

create_legend <- function(items, title, max_items, italic = FALSE, style = STYLE,
                          pos_x = 0.02, pos_y = 0.08, use_shapes = FALSE) {
  n_items <- min(nrow(items), max_items)
  has_more <- nrow(items) > max_items

  # Calculate dimensions
  title_h <- style$legend_item_height * 1.8
  content_h <- n_items * style$legend_item_height
  more_h <- if (has_more) style$legend_item_height * 1.2 else 0
  total_h <- title_h + content_h + more_h + style$legend_padding * 3

  # Find max label width using ONLY VISIBLE items (first n_items)
  visible_items <- items$label[1:n_items]
  max_label_len <- max(nchar(visible_items))
  legend_w <- max(style$legend_width, 0.01 * max_label_len + 0.06)

  # Position (from parameters, defaults to bottom-left)
  x0 <- pos_x
  y0 <- pos_y

  grobs <- list()

  # Background with rounded corners
  grobs$bg <- roundrectGrob(
    x = x0, y = y0,
    width = legend_w, height = total_h,
    just = c("left", "bottom"),
    r = unit(8, "pt"),
    gp = gpar(
      fill = alpha(style$legend_bg, style$legend_bg_alpha),
      col = style$legend_border,
      lwd = 1
    )
  )

  # Title
  grobs$title <- textGrob(
    toupper(title),
    x = x0 + style$legend_padding,
    y = y0 + total_h - style$legend_padding - title_h/2,
    just = c("left", "center"),
    gp = gpar(
      col = style$legend_title_color,
      fontsize = style$legend_title_size,
      fontface = "bold"
    )
  )

  # Legend items
  for (i in seq_len(n_items)) {
    item_y <- y0 + total_h - title_h - style$legend_padding - (i - 0.5) * style$legend_item_height

    # Get shape for this item (default to circle)
    item_shape <- if (use_shapes && "shape" %in% names(items)) items$shape[i] else "circle"

    # Shape/dot indicator
    if (use_shapes && item_shape != "circle") {
      # Use shape grob for non-circle shapes
      grobs[[paste0("shape_", i)]] <- create_shape_grob(
        x = x0 + style$legend_padding + 0.012,
        y = item_y,
        shape = item_shape,
        fill_color = items$color[i]
      )
    } else {
      # Default circle
      grobs[[paste0("dot_", i)]] <- circleGrob(
        x = x0 + style$legend_padding + 0.012,
        y = item_y,
        r = 0.006,
        gp = gpar(
          fill = items$color[i],
          col = alpha("white", 0.3),
          lwd = 0.5
        )
      )
    }

    # Label
    grobs[[paste0("label_", i)]] <- textGrob(
      items$label[i],
      x = x0 + style$legend_padding + 0.028,
      y = item_y,
      just = c("left", "center"),
      gp = gpar(
        col = style$legend_text_color,
        fontsize = style$legend_font_size,
        fontface = if (italic) "italic" else "plain"
      )
    )
  }

  # "More" indicator if truncated
  if (has_more) {
    grobs$more <- textGrob(
      sprintf("+ %d more...", nrow(items) - max_items),
      x = x0 + style$legend_padding,
      y = y0 + style$legend_padding + more_h/2,
      just = c("left", "center"),
      gp = gpar(
        col = style$legend_title_color,
        fontsize = style$legend_font_size - 1,
        fontface = "italic"
      )
    )
  }

  do.call(grobTree, grobs)
}

# ──────────────────────────────────────────────────────────────────────────────
# 10. PREPARE DATA WITH SHAPES (if enabled)
# ──────────────────────────────────────────────────────────────────────────────

# Add shape column to points based on species (or other grouping)
if (shapes_enabled && length(group_shapes) > 0) {
  cat("\\nApplying shapes to data points...\\n")

  # Get the grouping column (usually species for subspecies coloring)
  # The shape is assigned per species, so we need to map species -> shape
  points$shape_code <- sapply(points$species, function(sp) {
    shape_name <- group_shapes[[sp]]
    if (is.null(shape_name)) shape_name <- "circle"
    get_shape_code(shape_name)
  })

  # Also add shape column to legend_df for legend rendering
  if ("species" %in% names(legend_df)) {
    legend_df$shape <- sapply(legend_df$species, function(sp) {
      shape_name <- group_shapes[[sp]]
      if (is.null(shape_name)) "circle" else shape_name
    })
  } else {
    # If no species column, try to match by label
    legend_df$shape <- sapply(legend_df$label, function(lbl) {
      # Try to extract species from label (may be subspecies name with prefix)
      shape_name <- group_shapes[[lbl]]
      if (is.null(shape_name)) "circle" else shape_name
    })
  }

  cat(sprintf("  Shapes assigned: %d unique shapes\\n", length(unique(points$shape_code))))
} else {
  points$shape_code <- 21  # Default to circle
  legend_df$shape <- "circle"
}

# ──────────────────────────────────────────────────────────────────────────────
# 11. BUILD THE MAP
# ──────────────────────────────────────────────────────────────────────────────

cat("\\nCreating map...\\n")

# Start building the plot
p <- ggplot()

# Add basemap layer
if (!is.null(basemap)) {
  p <- p + geom_spatraster_rgb(data = basemap)
} else if (!is.null(basemap_png)) {
  p <- p + annotation_raster(
    basemap_png,
    xmin = bounds$xmin, xmax = bounds$xmax,
    ymin = bounds$ymin, ymax = bounds$ymax
  )
}

# Add data points with stroke (matching web app style)
# If shapes are enabled, use shape aesthetic; otherwise use fixed circle
if (shapes_enabled && "shape_code" %in% names(points)) {
  # Use per-point shapes
  # Note: shape must be mapped to a numeric for filled shapes (21-25)
  p <- p +
    geom_sf(
      data = points,
      aes(fill = display_color, shape = factor(shape_code)),
      color = alpha(STYLE$point_stroke_color, STYLE$point_stroke_alpha),
      size = STYLE$point_size,
      alpha = STYLE$point_alpha,
      stroke = STYLE$point_stroke_width
    ) +
    scale_fill_identity() +
    scale_shape_manual(
      values = c("21" = 21, "22" = 22, "23" = 23, "24" = 24, "25" = 25),
      guide = "none"  # Hide from ggplot's built-in legend (we use custom legend)
    )
} else {
  # Default: all circles
  p <- p +
    geom_sf(
      data = points,
      aes(fill = display_color),
      color = alpha(STYLE$point_stroke_color, STYLE$point_stroke_alpha),
      size = STYLE$point_size,
      alpha = STYLE$point_alpha,
      stroke = STYLE$point_stroke_width,
      shape = 21
    ) +
    scale_fill_identity()
}

# Set coordinate system and bounds
p <- p +
  coord_sf(
    xlim = c(bounds$xmin, bounds$xmax),
    ylim = c(bounds$ymin, bounds$ymax),
    expand = FALSE
  )

# Add scale bar using ggspatial
p <- p +
  annotation_scale(
    location = "br",
    width_hint = 0.15,
    style = "ticks",
    text_col = STYLE$scale_bar_color,
    line_col = STYLE$scale_bar_color,
    pad_x = unit(0.5, "cm"),
    pad_y = unit(0.5, "cm")
  )

# Apply theme
p <- p +
  theme_void() +
  theme(
    plot.background = element_rect(fill = STYLE$bg_color, color = NA),
    panel.background = element_rect(fill = STYLE$bg_color, color = NA)
  )

# Add custom legend with position and shape support
p_final <- p +
  annotation_custom(
    create_legend(
      legend_df,
      legend_data$title,
      legend_max_items,
      ${isItalic ? 'TRUE' : 'FALSE'},
      style = STYLE,
      pos_x = legend_pos_x,
      pos_y = legend_pos_y,
      use_shapes = shapes_enabled
    ),
    xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf
  )

# ──────────────────────────────────────────────────────────────────────────────
# 12. SAVE OUTPUTS
# ──────────────────────────────────────────────────────────────────────────────

cat("\\nSaving outputs...\\n")

# Preview in RStudio
print(p_final)

# Save as PDF (vector graphics for publications)
ggsave("ithomiini_map.pdf", plot = p_final,
       width = output_width, height = output_height, dpi = STYLE$dpi)
cat("  ithomiini_map.pdf\\n")

# Save as high-resolution PNG
ggsave("ithomiini_map.png", plot = p_final,
       width = output_width, height = output_height, dpi = STYLE$dpi)
cat("  ithomiini_map.png\\n")

# Save as SVG (editable vector)
ggsave("ithomiini_map.svg", plot = p_final,
       width = output_width, height = output_height, dpi = STYLE$dpi)
cat("  ithomiini_map.svg\\n")

cat("\\n════════════════════════════════════════════════════════════════════════════════\\n")
cat("Export complete!\\n")
cat("\\nOutput files:\\n")
cat("  ithomiini_map.pdf - Vector PDF for publications\\n")
cat("  ithomiini_map.png - High-resolution raster (300 DPI)\\n")
cat("  ithomiini_map.svg - Editable vector (Adobe Illustrator/Inkscape)\\n")
cat("\\nTip: Edit the STYLE list above to customize colors, sizes, and layout.\\n")
cat("════════════════════════════════════════════════════════════════════════════════\\n")
`
}

// Generate README for the ZIP
const generateReadme = (citationText) => {
  return `═══════════════════════════════════════════════════════════════════════════
ITHOMIINI MAPS - R EXPORT PACKAGE
═══════════════════════════════════════════════════════════════════════════

This ZIP contains data and scripts to recreate your map view as true
vector graphics (SVG/PDF) for publications.

FILES INCLUDED:
---------------
- data.geojson      : Filtered specimen data with pre-computed colors
- view_config.json  : Map view bounds and settings
- legend.json       : Legend colors and labels
- basemap.png       : Exact basemap from web app (CartoDB Dark tiles)
- map.html          : Standalone HTML file (EXACT reproduction of web preview)
- generate_map.R    : R script to recreate the map
- README.txt        : This file

QUICK START:
------------
1. Extract all files to a folder
2. Open R or RStudio
3. Set working directory to the extracted folder
4. Run: source("generate_map.R")
5. Find your exports in the folder

OUTPUT FILES:
-------------
- ithomiini_map.pdf : Vector PDF for publications
- ithomiini_map.png : High-resolution raster (300 DPI)
- ithomiini_map.svg : Editable vector (Adobe Illustrator/Inkscape)

REQUIREMENTS:
-------------
All packages will auto-install if missing:
- sf               : Spatial data handling
- ggplot2          : Plotting
- dplyr            : Data manipulation
- tidyr            : Data tidying
- jsonlite         : Reading config files
- maptiles         : CartoDB Dark Matter basemap tiles
- tidyterra        : Plot raster tiles with ggplot2
- ggspatial        : Scale bar
- grid             : Custom legend rendering
- png              : Read fallback basemap image

VIEWING IN BROWSER (map.html):
------------------------------
The map.html file is a standalone HTML file that renders identically to the
web app preview. You can open it directly in any browser to view and interact
with the map.

WHY R?
------
The web map uses WebGL rendering which produces raster (pixel) output.
R with ggplot2 renders true vectors, giving you:
- Infinite scalability for any print size
- Small file sizes
- Editable in Adobe Illustrator/Inkscape
- Publication-quality output

CUSTOMIZATION:
--------------
Edit the STYLE list in generate_map.R to easily customize:
- Point size, color, and transparency
- Legend position, size, and max items shown
- Background and text colors
- Scale bar styling
- Output dimensions and DPI

The script is well-documented and uses tidyverse conventions for
easy modification.

CITATION:
---------
${citationText}

SOURCE:
-------
https://fr4nzz.github.io/ithomiini_maps/

Generated: ${new Date().toISOString()}
Version: ${shortHash}
═══════════════════════════════════════════════════════════════════════════
`
}

// Generate standalone HTML file that renders exact same map as web app
const generateMapHTML = (geoJSON, viewConfig, legendConfig, colorBy) => {
  const isItalic = colorBy === 'species' || colorBy === 'subspecies' || colorBy === 'genus' || colorBy === 'scientific_name'
  const legendItems = legendConfig.items || []

  return `<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Ithomiini Distribution Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"><\/script>
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
    #map { width: 100vw; height: 100vh; }

    /* Legend - matches web app exactly */
    .legend {
      position: absolute;
      bottom: 40px;
      left: 20px;
      background: rgba(37, 37, 64, 0.95);
      border: 1px solid #3d3d5c;
      border-radius: 8px;
      padding: 12px;
      max-height: 60vh;
      overflow-y: auto;
      min-width: 180px;
      z-index: 1000;
    }
    .legend-title {
      color: #888888;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 3px 0;
    }
    .legend-color {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }
    .legend-label {
      color: #e0e0e0;
      font-size: 12px;
      ${isItalic ? 'font-style: italic;' : ''}
    }

    /* Scale bar */
    .maplibregl-ctrl-scale {
      background: rgba(37, 37, 64, 0.9) !important;
      color: #e0e0e0 !important;
      border-color: #e0e0e0 !important;
      font-size: 11px !important;
    }

    /* Hide attribution for cleaner export */
    .maplibregl-ctrl-attrib { display: none !important; }
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="legend">
    <div class="legend-title">${legendConfig.title || colorBy}</div>
    ${legendItems.map(item => `
    <div class="legend-item">
      <div class="legend-color" style="background: ${item.color}"></div>
      <span class="legend-label">${item.label}</span>
    </div>
    `).join('')}
  </div>

  <script>
    // GeoJSON data embedded
    const geoData = ${JSON.stringify(geoJSON)};

    // View config
    const config = ${JSON.stringify(viewConfig)};

    // Initialize map
    const map = new maplibregl.Map({
      container: 'map',
      style: {
        version: 8,
        sources: {
          'carto-dark': {
            type: 'raster',
            tiles: ['https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}@2x.png'],
            tileSize: 256,
            attribution: '© CartoDB © OpenStreetMap'
          }
        },
        layers: [{
          id: 'carto-dark-layer',
          type: 'raster',
          source: 'carto-dark',
          minzoom: 0,
          maxzoom: 22
        }]
      },
      center: [config.center.lng, config.center.lat],
      zoom: config.zoom,
      preserveDrawingBuffer: true // Required for canvas export
    });

    // Add scale bar
    map.addControl(new maplibregl.ScaleControl({ unit: 'metric' }), 'bottom-right');

    map.on('load', () => {
      // Add data source
      map.addSource('points', {
        type: 'geojson',
        data: geoData
      });

      // Add points layer with exact colors from web app
      map.addLayer({
        id: 'points-layer',
        type: 'circle',
        source: 'points',
        paint: {
          'circle-radius': 6,
          'circle-color': ['get', 'display_color'],
          'circle-opacity': 0.8,
          'circle-stroke-width': 1,
          'circle-stroke-color': 'rgba(255,255,255,0.3)'
        }
      });

      // Fit to bounds
      map.fitBounds([
        [config.bounds.west, config.bounds.south],
        [config.bounds.east, config.bounds.north]
      ], { padding: 20, duration: 0 });
    });
  <\/script>
</body>
</html>`
}

/**
 * Export data for R - generates a ZIP file with all necessary files
 * @param {Object} map - The MapLibre map instance
 * @returns {Promise<void>}
 */
export async function exportForR(map) {
  if (!map) {
    throw new Error('Map not available. Please ensure you are on the Map view.')
  }

  const store = useDataStore()
  const geo = store.filteredGeoJSON

  if (!geo || !geo.features || geo.features.length === 0) {
    throw new Error('No data to export')
  }

  // Get map bounds directly (map container is sized to aspect ratio)
  const mapBounds = map.getBounds()
  const center = map.getCenter()
  const zoom = map.getZoom()

  // Prepare GeoJSON with color information
  const colorMap = store.activeColorMap
  const colorBy = store.colorBy

  // Add color to each feature
  const featuresWithColors = geo.features.map(f => {
    const key = f.properties[colorBy] || 'Unknown'
    return {
      ...f,
      properties: {
        ...f.properties,
        display_color: colorMap[key] || '#888888'
      }
    }
  })

  const exportGeoJSON = {
    type: 'FeatureCollection',
    metadata: {
      title: 'Ithomiini Distribution Data',
      version: shortHash,
      exportDate: new Date().toISOString(),
      recordCount: geo.features.length,
      colorBy: colorBy,
      source: 'https://fr4nzz.github.io/ithomiini_maps/'
    },
    features: featuresWithColors
  }

  // Calculate aspect ratio from map container
  const container = map.getContainer()
  const aspectRatio = container.clientWidth / container.clientHeight

  // View configuration (using map bounds directly)
  const viewConfig = {
    bounds: {
      west: mapBounds.getWest(),
      south: mapBounds.getSouth(),
      east: mapBounds.getEast(),
      north: mapBounds.getNorth()
    },
    center: {
      lng: center.lng,
      lat: center.lat
    },
    zoom: zoom,
    colorBy: colorBy,
    aspectRatio: aspectRatio  // Used by R to set correct output dimensions
  }

  // Get legend store settings
  const legendStore = useLegendStore()

  // Legend configuration - preserve order from colorMap (which matches web app display order)
  // Get legend items in the same order as they appear in the web app
  // Include species name for shape lookup
  const legendItems = Object.entries(colorMap).map(([label, color]) => {
    // Try to determine species from the label (for subspecies coloring)
    const parts = label.split(' ')
    const species = colorBy === 'subspecies' && parts.length >= 2
      ? `${parts[0]} ${parts[1]}` // First two words are usually genus + epithet
      : label

    return {
      label,
      color,
      species,
      // Include shape if shapes are enabled
      shape: legendStore.getGroupShape(species)
    }
  })

  // Build abbreviations map for all species
  const speciesSet = new Set(legendItems.map(item => item.species))
  const abbreviationsMap = {}
  const displayNamesMap = {}

  for (const species of speciesSet) {
    // Get abbreviation (prefix for subspecies)
    const abbrev = legendStore.speciesAbbreviations[species] ||
      applyAbbreviationFormat(species, legendStore.prefixFormat)
    if (abbrev) abbreviationsMap[species] = abbrev

    // Get display name (for group headers)
    const displayName = legendStore.speciesDisplayNames[species] ||
      applyAbbreviationFormat(species, legendStore.displayNameFormat)
    if (displayName) displayNamesMap[species] = displayName
  }

  // Build group shapes map
  const groupShapesMap = { ...legendStore.groupShapes }

  // Normalize legend position to 0-1 scale for R
  // Web app uses pixel positions, R uses normalized coordinates
  // Note: 'container' was already declared above for aspect ratio calculation
  const containerWidth = container.clientWidth
  const containerHeight = container.clientHeight
  const legendPosX = legendStore.position.x !== null
    ? Math.max(0.01, Math.min(0.9, legendStore.position.x / containerWidth))
    : 0.02
  const legendPosY = legendStore.position.y !== null
    ? Math.max(0.05, Math.min(0.9, 1 - (legendStore.position.y / containerHeight)))
    : 0.08

  const legendConfig = {
    title: store.legendTitle,
    colorBy: colorBy,
    maxItems: legendStore.maxItems || store.legendSettings.maxItems,
    colors: colorMap,
    items: legendItems,
    // Legend customization settings
    showHeaders: legendStore.groupingSettings.showHeaders,
    displayNameFormat: legendStore.displayNameFormat,
    prefixFormat: legendStore.prefixFormat,
    shapesEnabled: legendStore.shapeSettings.enabled,
    // Custom values
    displayNames: displayNamesMap,
    abbreviations: abbreviationsMap,
    groupShapes: groupShapesMap,
    // Position (normalized 0-1)
    position: {
      x: legendPosX,
      y: legendPosY
    }
  }

  // Generate R script with legend settings
  const rScript = generateRScript(colorBy, {
    position: legendStore.position,
    showHeaders: legendStore.groupingSettings.showHeaders,
    displayNameFormat: legendStore.displayNameFormat,
    prefixFormat: legendStore.prefixFormat,
    shapesEnabled: legendStore.shapeSettings.enabled
  })

  // Capture basemap as raster (without data points)
  let basemapDataUrl = null
  const dataLayers = ['points-layer', 'points-glow', 'clusters', 'cluster-count']
  const layerVisibility = {}

  try {
    // Temporarily hide data layers to capture just the basemap
    dataLayers.forEach(layerId => {
      if (map.getLayer(layerId)) {
        layerVisibility[layerId] = map.getLayoutProperty(layerId, 'visibility')
        map.setLayoutProperty(layerId, 'visibility', 'none')
      }
    })

    // Wait for render
    map.triggerRepaint()
    await new Promise(resolve => map.once('idle', resolve))

    // Capture basemap canvas directly (no cropping needed)
    basemapDataUrl = map.getCanvas().toDataURL('image/png')
  } catch (e) {
    console.warn('[Export] Could not capture basemap:', e)
  } finally {
    // ALWAYS restore layer visibility, even if capture failed
    dataLayers.forEach(layerId => {
      if (map.getLayer(layerId)) {
        const originalVisibility = layerVisibility[layerId]
        if (originalVisibility !== undefined) {
          map.setLayoutProperty(layerId, 'visibility', originalVisibility || 'visible')
        } else {
          // If we didn't capture original state, default to visible
          map.setLayoutProperty(layerId, 'visibility', 'visible')
        }
      }
    })

    // Wait for render to restore
    map.triggerRepaint()
    await new Promise(resolve => map.once('idle', resolve))
  }

  // Generate citation text
  const citationText = getCitationText(geo.features.length)

  // Generate HTML file for exact reproduction
  const mapHTML = generateMapHTML(exportGeoJSON, viewConfig, legendConfig, colorBy)

  // Create ZIP file
  const zip = new JSZip()
  zip.file('data.geojson', JSON.stringify(exportGeoJSON, null, 2))
  zip.file('view_config.json', JSON.stringify(viewConfig, null, 2))
  zip.file('legend.json', JSON.stringify(legendConfig, null, 2))
  zip.file('generate_map.R', rScript)
  zip.file('map.html', mapHTML)
  zip.file('README.txt', generateReadme(citationText))

  // Add basemap if captured
  if (basemapDataUrl) {
    const basemapBase64 = basemapDataUrl.split(',')[1]
    zip.file('basemap.png', basemapBase64, { base64: true })
  }

  // Generate and download ZIP
  const content = await zip.generateAsync({ type: 'blob' })
  const url = URL.createObjectURL(content)
  const link = document.createElement('a')
  link.href = url
  link.download = `ithomiini_r_export_${shortHash}_${Date.now()}.zip`
  link.click()
  URL.revokeObjectURL(url)
}
